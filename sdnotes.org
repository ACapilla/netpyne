* 14jun18 Created repo
** TODO port msarm to M1 model
*** DONE 1) add the input Proprioceptive population, which is actually really a set of netstims with location (NSLOCs), and connect them to layer 2 
*** TODO 2) Add RL: weight changes at synapses, eligibility traces, stdp-like rule, keep track of target location and arm position (receive via udp every 10ms) to calculate error periodically,
**** DONE Make plexon input be optional 
**** TODO replace arminterface with arminterface_pipe.py - set an option so can use dummy virtual arm for testing!
**** TODO implement msarm.hoc (arm apparatus such as target location, arm position, error etc) in new python-based M1 model
**** TODO RL and eligibility traces using George's PYNDL code
*** TODO 3) Assign SPI subpopulations to different muscles (or maybe just random, which would make more realistic), convert from firing rates to muscle excitation (currently, just sum+threshold), and send udp packet with muscle excitations to arm every 10ms.
***  TODO 4) Assign muscle lengths to the proprioceptive neurons and make them fire accordingly; requires updating muscle lengths every 10ms (via received udp messages)
*** TODO 5) Add the training, testing, and analysis functions
*** TODO decide where plasticity will happen
-should modify the connectivity and weights tuned to M1!?
-maybe avoid by adding plastic connections ONLY between proprioception to L2/3? and SPI to spinal cord interneurons; use spinal cord to project to muscles 
*** TODO Encode target/PMd activity in input to L2/3 or in external noise input patterns 
- PMd poisson from neural field model/SSM?)
- use SSM from Marius, and convert to Poisson(?) a la cliff
- Train with SSM noise for each of the targets
- Test with initial/preparatory  PMd input??
* 14sep19 First improvements by Giljael and me
** README by Gil
1.How to add new cell types in the model:
<plx_cellpopdata.py>
Insert cell info in lists like PMd case.
popnames = ['PMd', 'ER2', 'IF2', 'IL2', 'ER5', 'EB5', 'IF5', 'IL5', 'ER6', 'IF6', 'IL6']
popclasses =  [-1,    1,     2,     3,     1,     1,     2,     3,     1,     2,     3] # Izhikevich population type
popEorI =     [ 0,    0,     1,     1,     0,     0,     1,     1,     0,     1,     1] # Whether it's excitatory or inhibitory
popratios =  [numPMd,150,    25,    25,   167,    72,    40,    40,   192,    32,    32]
Prior cells will have lower gids. E.g., PMd.gid < ER2.gid <...<IL6.gid

Change cellproperties() according to the cell types:
cell info is returned to plx_model and the info is used for simulations.
For PMd type cells, the following is added, because the number of PMd cells are not changed as scale changes.
If cells increase in the cell types as scale increases, the following modification is not needed.
    indexPopName = checkIndexPopName('PMd', popnames) # checkIndexPopName returns PMd index in popnames
    if not indexPopName == -1:
        popnumbers[indexPopName] = numPMd # Number of PMds is fixed. # return back the number of PMd cells to numPMd.
"ncells" is a global value, and total number of cells in the model.

According to the cell types added, return statement in names2inds() and its call in plx_cellpopdata.py and plx_model.py should be updated.

def setconnprobs() needs connection probabilities for new cell types. Currently inserting PMds doesn't modify this function.

def setconnweights() needs new connection weight. For the PMds, connweights[PMd,ER2,AMPA]=10 was added.

<In plx_model.py>
Update "## set cell types." @Line 189
For PMd, "elif cellclasses[c]==-1: celltypes.append(pmdnsloc)" is added. pmdnsloc is defined in nsloc.py

Update "## set positions." @Line 202
Positions are changed. That is, if new cell types are added in the model, existing cells in the model will have different positions because of randomness change.
xlocs = modelsize*rand(ncells) # Create random x locations
ylocs = modelsize*rand(ncells) # Create random y locations
zlocs = verticalextent*rand(ncells) # Create random z locations
Add zlayer position update. For PMd, "elif cellnames[c][-1]=='d': zlocs[c]+=zlayerpositions[5]" is added. 'd' is in 'PMd'.

Update "## Actually create the cells." @Line 221
In this version(r2206 in SVN), all cells including new cells inserted are distributed evenly in a round-robin way by "for c in xrange(int(pc.id()), ncells, nhosts):."
"cellsperhost" indicates how many cells including new cell types inserted each worker created. Each worker might have different value of cellsperhost. 
For PMd, the following code snippet is executed for NULL->NetCon->PMd connection. NSLOC-based cell types will follow the code snippet, but inncl is only to feed PMds with external PMd spikes:
   if cellnames[gid] == 'PMd':
     cell = celltypes[gid](cellid = gid) # create an NSLOC
     inncl.append(h.NetCon(None, cell)) # This netcon will receive external PMd spikes
     innclDic[gid] = ninnclDic          # This dictionary will be used for NetCon search.
     ninnclDic += 1
   else:

Update ##calculate distance and probabilities. @Line 256
Connection probabilities among cells are calculated prior to making connections,  
However, PMds won't be post synaptic cells in the connections. So the following code snippet is only for PMds: 
   if cellnames[gid] == 'PMd':
      # There is no connection for cells -> PMds
      continue  
In order to make connections between the new cells added and others based on probabilities, def setconnprobs() in plx_cellpopdata.py should be modified accordingly. 
Connection between a ER2 and PMd is controlled explicitly by PMd[gid%numPMd]->ER2[gid]. So, if you want to control the connections for other cells, follow the code for PMds:

pmdStart = cpd.popGidStart[PMd] # get pmd's start gid by using cpd.popGidStart[cellname]
pmdEnd = cpd.popGidEnd[PMd]     # get PMd's end gid
for c in xrange(pmdStart, pmdEnd + 1):
   allrands[c] = 1 # set all PMd values in allrands to 1.
if cellnames[gid] == 'ER2':
  pMdId = (gid % numPMd)  # select PMd being connected to this ER2 cell.
  allconnprobs[pMdId] = 1 # to make this PMd connected to the ER2 cell
  allrands[pMdId] = 0     # to make this PMd connected to the ER2 cell
  distances[pMdId] = 300  # to make the NetCon delay for this connection 5ms

Update ## Add background inputs @Line 447
ER2 and PMd cells won't be fired by background spikes. The following avoid them not to be fired by background spikes:
gid = gidvec[c]
if isOriginal == 0:
    if cellnames[gid] == 'ER2' or cellnames[gid] == 'PMd': # 'ER2' won't be fired by background stimulations.
        continue

2.How to connect m1ms with Plexon?
# Connect m1ms with Plexon
- Copy m1ms/sim/Client to Windows machine having MATLAB and Plexon software.
- Open Client/plx_mat_interface.m on the Windows machine, and set up "remoteAddr" to the IP address m1ms runs on. In addition, set up "addapth" with the path for the library required for the Plexon software.
- Set up parameters in m1ms/sim/config.py accordingly.
  isOriginal|isCommunication|isQueueTest
  a. 1 | x | x - To run the original m1ms (Cliff's parallelized model). X means don't care
  b. 0 | 1 | 1 - To run m1ms w/o connection to Plexon, but with PMd spike files
  c. 0 | 1 | 0 - To run m1ms, getting spikes from Plexon through the communication program
  Note: for b and c, check if PMd spike file (spikePMd-6sec.txv) is in data/.

3. How to run m1ms?
For 2.a, 2.b:
$plx_runsim <# of workers>

For 2.c,
1. $plx_runsim <# of workers>
2. Run client in the Windows machine.
3. Run the Plexon softsever.

4. How to plot raster, lfp and power spectra?
Spikes are stored in m1ms/sim/m1ms-spk.txt and m1ms-spk.txt.mat
Just run python fileplots.py m1ms-spk.txt. It stores plots to files.
$python fileplots.py m1ms-spk.txt



** List of changes by Gil
- Added PMd population receiving external input 
- Cells (inlcuidng PMd) distributed over workers using round-robin (each worker doesnt have same number of cells)
- Cells not referenced by realtive id, so easier to add and reference cells
- Master worker gets data from PMd cells and broadcasts it to other workers
- With PMd data, 30 workers over 10 nodes, and 10 scale (7846 cells), this model (6sec sim) runs in real-time (6sec).
- Added P population (proprioceptive from virtual arm) and udp interface to arm
** List of changes by me
- Tidied up code and merged with cliff's tutorial code
- Included generic stimulation code based on classes, eg. class for 'natural touch', class for 'optogenetic'

