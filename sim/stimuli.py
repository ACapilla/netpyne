"""
STIMULI

This code generates the natural touch and microstim stimuli.

Known bugs: for some reason this code seems to give an offset of about 50 ms
with the stimulus time (i.e. the peak is 50 ms before the event time). Think
it arises since the Gaussian is 100 points long, and the stimulus event time is 
in the middle of it rather than the beginning.

Input arguments are:
 1. ISI (s)
 2. ISI variation (s)
 3. Stimulus width (s)
 4. Stimulus start (s)
 5. Stimulus finish (s)
 
[6. ISI (s)
 7. ISI variation (s)
 8. Stimulus width (s)
 9. Stimulus start (s)
10. Stimulus finish (s)]
 
[...]

I takes blocks of 5 arguments; each block is one type of stimulus.

Version: 2013oct25
"""

print("Creating stimulus...")

###############################################################################
### SET PARAMETERS
###############################################################################

# Natural stimuli
usenaturalstimuli = True
	naturalstimpop=new Vector()
	{naturalstimpop.append(TC)}
	naturalstimrate=100 # Maximum number of spikes/s in natural stimulus
	naturalstimprct=100 # Percent of cells that are being stimulated
	naturalstimweight=100 # stimulus weight
	naturallayers=1e9 # Which layers to select -- 1e9 for all
	naturalstimradius=200 # Radius of selection
	naturalxstimpos=colside/2 # Where in the column to put the stimulus
	naturalystimpos=colside/2 # ...and in the other dimension

# Random MiSt stimuli
userandommist=0
	miststimpop=new Vector()
	{miststimpop.append(E4,E5B,E5R)}
	miststimrate=20 # Maximum number of spikes/s in mist stimulus
	miststimprct=10 # Percent of cells that are being stimulated
	miststimweight=30 # stimulus weight
	mistlayers=1e9 # Which layers to select -- 1e9 for all; overruled by stimstimpop
	miststimradius=colside # Radius of selection
	mistxstimpos=colside/2 # Where in the column to put the stimulus
	mistystimpos=colside/2 # ...and in the other dimension
	
# Spike-triggered MiSt
usespiketriggeredmist=0
	spiketriggeredmistpops=new Vector()
	{spiketriggeredmistpops.append(E5B,E5R)}
	spiketriggeredmistcontrolcell=491*scale # Make sure it's always an I2 cell
	spiketriggeredmistpercent=10 # Percent of cells being stimulated
	spiketriggeredmistweight=30
	spiketriggeredmistdelay=10
	spiketriggeredmistthreshold=10




##########
# NATURAL STIMULUS
##########
if (usenaturalstimuli) {
	print "  Creating natural stimulus..."
	# Read in stimulus from file
	strdef naturalinputfile
	naturaldatafile = new File()
	naturaltsignal = new Vector()
	naturalpsignal = new Vector()
	naturalcellids = new Vector()
	naturalstimcellpops=naturalstimpop.size()
	# Read files
	for file=0,1 {
		sprint(naturalinputfile,"%s-in%1.0f.txt",filestem,file*2+1) # Want to loop over files 1 and 3
		naturaldatafile.ropen(naturalinputfile) # Open file ("out file name 5") for reading; generated by makenaturalstims.py
		while (!naturaldatafile.eof()) { # Read from the data file
			naturaltsignal.append(naturaldatafile.scanvar()) # Read time point
			naturalpsignal.append(naturaldatafile.scanvar()) # Read probability
			naturaldatafile.scanvar() # Read and reject event data, which is the third column
			}
		naturaldatafile.close() # Close the input file
	}
	naturalstimrate/=1000 # Convert from Hz to ms^-1

	# Add stimulus to a particular spatial region (...receptive field?)
	naturalstimselectedcells = new NQS("cellid","distance")
	for i=0,naturalstimcellpops-1 {
		col.ce.o[0].floc(naturalxstimpos,naturalystimpos,naturallayers,naturalstimselectedcells.getcol("cellid"),naturalstimselectedcells.getcol("distance"),naturalstimradius,naturalstimpop.x[i])
		naturaltmpids=naturalstimselectedcells.getcol("cellid") # Only need the cell ID
		naturalcellids.append(naturaltmpids) # Append to the list of all cell IDs
	}
	if (naturalcellids.size>0) {
		print "Number of cells receiving natural stimulus: ", naturalcellids.size()
		naturalsynapse=AM2 # Which synapsenapses to stimulate
		poisforcell(naturaltsignal,naturalpsignal,naturalstimrate,naturalcellids,naturalstimweight,naturalsynapse) # Add natural stimulus
	} else print "WARNING: no cells received natural stimuli!"
}



#######
# RANDOM MIST
#######
if (userandommist) {
	print "Creating mist stimulus..."
	# Read in stimulus from file
	strdef mistinputfile
	mistdatafile = new File()
	misttsignal = new Vector()
	mistpsignal = new Vector()
	mistcellids = new Vector()
	miststimcellpops=miststimpop.size()
	sprint(mistinputfile,"%s-in2.txt",filestem)
	mistdatafile.ropen(mistinputfile) # Open file ("out file name 5") for reading; generated by makemiststims.py
	while (!mistdatafile.eof()) { # Read from the data file
		misttsignal.append(mistdatafile.scanvar()) # Read time point
		mistpsignal.append(mistdatafile.scanvar()) # Read probability
		mistdatafile.scanvar() # Read and reject event data, which is the third column
		}
	mistdatafile.close() # Close the input file
	miststimrate/=1000 # Convert from Hz to ms^-1

	# Add stimulus to a particular spatial region (...receptive field?)
	miststimselectedcells = new NQS("cellid","distance")
	for i=0,miststimcellpops-1 {
		col.ce.o[0].floc(mistxstimpos,mistystimpos,mistlayers,miststimselectedcells.getcol("cellid"),miststimselectedcells.getcol("distance"),miststimradius,miststimpop.x[i])
		misttmpids=miststimselectedcells.getcol("cellid") # Only need the cell ID
		mistcellids.append(misttmpids) # Append to the list of all cell IDs
	}
	if (mistcellids.size>0) {
		print "Number of cells receiving random MiSt stimulus: ", mistcellids.size()
		mistsynapse=AM2 # Which synapsenapses to stimulate
		poisforcell(misttsignal,mistpsignal,miststimrate,mistcellids,miststimweight,mistsynapse) # Add mist stimulus
	} else print "WARNING: no cells received mist stimuli!"
}



if (userandommist || usenaturalstimuli || hybriddrive) setshock(0) # If no argument, it resets the stimulus I believe...



############
# SPIKE-TRIGGERED MIST
############
# This code adds a cell-triggered microstim input 
# to an intfcol-derived simulation. Adapted from 
# wire2col in col.hoc.
# Version: 2012may23

proc startmist() { celllist.o(spiketriggeredmistcontrolcell).flag("dead",0) }
proc stopmist()  { celllist.o(spiketriggeredmistcontrolcell).flag("dead",1) }
proc startmistwrapper() { cvode.event(mist1sta*1000,"startmist()") }
proc stopmistwrapper()  { cvode.event(mist1fin*1000,"stopmist()") }

if (usespiketriggeredmist) {
	celllist=col.ce
	precell=celllist.o(spiketriggeredmistcontrolcell)
	precell.flag("out",1)
	microstim = new List()
	for cell=0,celllist.count-1 {
		postcell = celllist.o(cell)
		if (cell!=spiketriggeredmistcontrolcell && spiketriggeredmistpops.contains(postcell.type) && spiketriggeredmistpercent>100*randcond.repick()) { # Don't add a connection if: it's the firing cell; it's the wrong population; the probability doesn't meet the threshold
			netcon=new NetCon(precell,postcell,spiketriggeredmistthreshold,spiketriggeredmistdelay,spiketriggeredmistweight)
			microstim.append(netcon)
		}
	}
	print "Number of cells receiving spike-triggered MiSt: ", microstim.count()
	print "Population type of control cell: ", celllist.o(spiketriggeredmistcontrolcell).type
	
	stopmist()
	eventwrapper[0] = new FInitializeHandler("startmistwrapper()")
	eventwrapper[1] = new FInitializeHandler("stopmistwrapper()")
}




from sys import argv
from numpy import random
from pylab import savetxt, r_, exp, zeros, size, convolve, vstack

argsperblock=5;
nargs=argv.__len__()-1 # Number of input arguments
nstimblocks=(nargs-1)/argsperblock # Number of stimulus blocks, e.g. mist/natural touch/mist = 3
assert nstimblocks>0, "Not enough input arguments!"


# Handle input arguments
allisi=[]; allvariation=[]; allsigma=[]; allstart=[]; allfinish=[]
try: 
    outfilestem=argv[1] # File name stem
    for block in range(nstimblocks):
        allisi.append(float(argv[2+argsperblock*block])) # Interstimulus interval
        allvariation.append(float(argv[3+argsperblock*block])) # Variation in interstimulus interval
        allsigma.append(float(argv[4+argsperblock*block])) # Stimulus width in log-seconds or something weird like that
        allstart.append(float(argv[5+argsperblock*block])) # Duration of input
        allfinish.append(float(argv[6+argsperblock*block])) # Duration of input
except: 
    print "Not enough inputs! Needs 1 + blocks of 5."

for block in range(nstimblocks):
    isi=allisi[block]  
    variation=allvariation[block]
    sigma=allsigma[block]
    start=allstart[block]
    finish=allfinish[block]
    
    # Create event times
    random.seed(seed=1) # Make it pseudorandom
    timeres=0.005 # Time resolution = 5 ms = 200 Hz
    currenttime=start
    output=[]
    while currenttime<finish:
        currenttime=currenttime+isi+variation*(random.rand()-0.5)
        if currenttime<finish: output.append(currenttime)
    
    # Create Gaussian
    npts=0.3/timeres # Calculate the number of points in a 300 ms long Gaussian
    x=(r_[0:npts]-npts/2+1)*timeres
    y=exp(-((x)/sigma/2)**2)
    gaussian=y/max(y)
    
    # Create full stimulus
    allpts=(finish-start)/timeres
    events=zeros((allpts))
    for i in range(size(output,0)):
        thisindex=int((output[i]-start)/timeres)
        events[thisindex]=1
    fulloutput=convolve(events,gaussian,mode='same')
    fulltime=r_[start/timeres:finish/timeres]*timeres*1000 # Create time vector and convert to ms
    timeprob=vstack([fulltime,fulloutput,events]).T # Combine vectors into a matrix
    
    outfilename="%s-in%i.txt" % (outfilestem,block+1)
    savetxt(outfilename,timeprob,fmt='%11.3f')
    
    print "Stimulus file %s saved." % outfilename
